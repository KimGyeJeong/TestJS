// #1

// var funcs = [];

// for (var i = 0; i < 3; i++) {
//     funcs[i] = function () { return i; };
// }

// for (var j = 0; j < funcs.length; j++) {
//     console.log(funcs[j]());
// }

/*
첫번째 for 문의 코드 블록내에서 함수가 funcs 배열의 요소로 추가됨.
그리고 두번째 for 문의 코드 블록내 에서 funcs 배열의 요소로 추가된 함수를 순차적으로 호출됨.
원한 결과값은 0, 1, 2 지만 실제로는 3, 3, 3이 출력된다
*/

//#2

//클로저를 사용해 위의 코드를 수정하기
// var funcs = [];

// for (var i = 0; i < 3; i++) {
//     funcs[i] = (function (id) {
//         return function () {
//             return id;
//         }
//     }(i));
// }

// for (var j = 0; j < funcs.length; j++) {
//     console.log(funcs[j]());
// }

/*
첫번째 for문 안에서 즉시 실행 함수는 전역 변수 i에 할당되어 있는 값을 인수로 전달받아 매개변수 id에 할당한 후 
중첩 함수를 반환하고 종료된다. 즉시 실행 함수가 변환한 함수는 funcs 배열에 순차적으로 저장됨.
 즉시 실행 함수의 매개변수 id는 즉시 실행 함수가 반환한 중첩 함수의 상위 스코프에 존재함. 
즉시 실행 함수가 반환한 중첩 함수는 자신의 상위 스코프(즉시 실행 함수의 렉시컬 환경)를 기억하는 클로저이고,
매개변수 id는 즉시 실행 함수가 반환한 중첩 함수에 묶여있는 자유 변수가 되어 그 값이 유지됨.

사실 위의 코드들은 var 키워드로 선언한 변수가 전역 변수가 되기 때문에 발생한 현상이기 때문에 let을 사용하면 해결됨.
*/

//#2.1

// const funcs = [];

// for (let i = 0; i < 3; i++) {
//     funcs[i] = function () { return i; };
// }

// for (let j = 0; j < funcs.length; j++) {
//     console.log(funcs[j]());
// }
//0 1 2 출력

/*
for문의 변수 선언문에서 let 키워드로 선언한 변수를 사용하면 for 문의 코드 블록이 반복 실행될 때마다 for문 코드 블록의 
새로운 렉시컬 환경이 생성됨. 만약 for 문의 코드 블록 내에서 정의한 함수가 있다면 이 함수의 상위 스코프는 for 문의 코드 블록이
반복 실행될 때마다 생성된 for문 코드 블록의 새로운 렉시컬 환경이다.

함수의 상위 스코프는 for 문의 코드 블록이 반복 실행될 때마다 식별자(for 문의 변수 선언문에서 선언한 초기화 변수 및 for문의
    코드 블록내에서 선언한 지역 변수 등)의 값을 유지해야 한다. 이를 위해 for 문이 반복될 때마다 독립적인 렉시컬 환경을 생성하여
    식별자의 값을 유지한다.
*/

//#2.9
/*
함수형 프로그래밍 기법인 고차 함수를 사용하는 방법.
이 방법은 변수와 반복문의 사용을 억제할 수 있기 때문에 오류를 줄이고 가독성을 좋게 만듬.
*/

//요소가 3개인 배열을 생성하고 배열의 인덱스를 반환하는 함수를 요소로 추가함
//배열의 요소로 추가된 함수들은 모두 클로저이다.

const funcs = Array.from(new Array(3), (_, i) => () => i);
console.log(funcs); //(3) [ƒ, ƒ, ƒ]

funcs.forEach(f => console.log(f()));
//0 1 2