/*
클로저. closure

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.
여기서 핵심 키워드는 '함수가 선언된 렉시컬 환경' 이다.

*/

//#1

// const x = 1;

// function outerFunc() {
//     const x = 10;

//     function innerFunc() {
//         console.log(x); //10
//     }

//     innerFunc();

// }

// outerFunc();

/*
outerFunc 함수 내부에서 중첩 함수 innerFunc가 정의되고 호출됨.
이때 중첩 함수 innerFunc의 상위 스코프는 외부 함수 outerFunc의 스코프.
따라서 중첩 함수 innerFunc 내부에서 자신을 포함하고 있는 외부 함수 outerFunc의 x 변수에 접근할 수 있음

만약 innerFunc 함수가 outerFunc 함수의 내부에서 정의된 중첩 함수가 아니라면
innerFunc 함수를 outerFunc 함수의 내부에서 호출한다 하더라도 outerFunc 함수의 변수에 접근할 수 없음
*/

//#2

// const x = 1;

// function outerFunc() {
//     const x = 10;
//     innerFunc();
// }
// function innerFunc() {
//     console.log(x); //1
// }

// outerFunc();

/*
이러한 현상이 일어나는 이유는 자바스크립트가 렉시컬 스코프를 따르는 프로그래밍 언어이기 때문
*/

//#3
/*
렉시컬 스코프(정적 스코프)란
자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정하는 것 이다
*/

// const x = 1;
// function foo() {
//     const x = 10;
//     bar();
// }
// function bar() {
//     console.log(x);
// }

// foo();  //1
// bar();  //1

/*
foo 함수와 bar 함수는 모두 전역에서 정의된 전역 함수이다.
함수의 상위 스코프는 함수를 어디서 정의 했느냐에 따라 결정되므로 foo함수와 bar 함수의 상위 스코프는 전역이다.
함수를 어디서 호출하는지는 함수의 상위 스코프 결정에 어떠한 영향도 주지못한다.
즉, 함수의 상위 스코프는 함수를 정의한 위치에 의해 정적으로 결정되고 변하지 않는다.

렉시컬 환경의 '외부 렉시컬 환경에 대한 참조'에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가
 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정됨. --> 렉시컬 스코프
*/

//#4 함수 객체의 내부 슬롯[[Environment]]
/*
함수가 정의된 환경(위치)과 호출되는 환경(위치)은 다를 수 있다.
렉시컬 스코프가 가능하려면 함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경, 상위 스코프를 기억해야 함.
이를 위해 함수는 자신의 내부 슬롯[[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장함.

함수 객체의 내부 슬롯[[Environment]]에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프임.
또한 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 '외부 렉시컬 환경에 대한 참조'에 저장될 참조값임.
함수 객체는 내부 슬롯[[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억함.
*/

// const x = 1;

// function foo() {
//     const x = 10;

//     //상위 스코프는 함수 정의 환경(위치)에 따라 결정됨
//     //함수 호출 위치와 상위 스코프는 아무런 관계가 없음
//     bar();
// }

// //함수 bar 는 자신의 상위 스코프, 즉 전역 렉시컬 환경을 [[environment]]에 저장하여 기억함
// function bar() {
//     console.log(x);
// }

// foo();  //1
// bar();  //1

/*
함수가 호출되면 함수 내부로 코드의 제어권이 이동. 그리고 함수 코드를 평가하기 시작하는데 그 순서는 다음과 같이 진행.

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
    2-1. 함수 환경 레코드 생성
    2-2. this바인딩
    2-3. 외부 렉시컬 환경에 대한 참조 결정

이때 함수 렉시컬 환경의 구성 요소인 외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯[[Environment]]에 
저장된 렉시컬 환경의 참조가 할당됨.
*/